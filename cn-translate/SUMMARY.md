# Summary

* [介绍](README.md)
* [第 1 章 Spring 入门](Chapter-01/Introduction.md)
    * [1.1 什么是 Spring？](Chapter-01/1.1-What-is-Spring.md)
    * [1.2 初始化 Spring 应用程序](Chapter-01/1.2-Initializing-a-Spring-application/Introduction.md)
        * [1.2.1 使用 Spring Tool Suite 初始化 Spring 项目](Chapter-01/1.2-Initializing-a-Spring-application/1.2.1-Initializing-a-Spring-project-with-Spring-Tool-Suite.md)
        * [1.2.2 检查 Spring 项目结构](Chapter-01/1.2-Initializing-a-Spring-application/1.2.2-Examining-the-Spring-project-structure.md)
    * [1.3 编写 Spring 应用程序](Chapter-01/1.3-Writing-a-Spring-application/Introduction.md)
        * [1.3.1 处理 web 请求](Chapter-01/1.3-Writing-a-Spring-application/1.3.1-Handling-web-requests.md)
        * [1.3.2 定义视图](Chapter-01/1.3-Writing-a-Spring-application/1.3.2-Defining-the-view.md)
        * [1.3.3 测试控制器](Chapter-01/1.3-Writing-a-Spring-application/1.3.3-Testing-the-controller.md)
        * [1.3.4 构建并运行应用程序](Chapter-01/1.3-Writing-a-Spring-application/1.3.4-Building-and-running-the-application.md)
        * [1.3.5 了解 Spring Boot DevTools](Chapter-01/1.3-Writing-a-Spring-application/1.3.5-Getting-to-know-Spring-Boot-DevTools.md)
        * [1.3.6 回顾](Chapter-01/1.3-Writing-a-Spring-application/1.3.6-Let's-review.md)
    * [1.4  俯瞰 Spring 风景线](Chapter-01/1.4-Surveying-the-Spring-landscape/Introduction.md)
        * [1.4.1 Spring 核心框架](Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.1-The-core-Spring-Framework.md)
        * [1.4.2 Spring Boot](Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.2-Spring-Boot.md)
        * [1.4.3 Spring Data](Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.3-Spring-Data.md)
        * [1.4.4 Spring Security](Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.4-Spring-Security.md)
        * [1.4.5 Spring Integration 和 Spring Batch](Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.5-Spring-Integration-and-Spring-Batch.md)
        * [1.4.6 Spring Cloud](Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.6-Spring-Cloud.md)
        * [1.4.7 Spring Native](Chapter-01/1.4-Surveying-the-Spring-landscape/1.4.7-Spring-Native.md)
    * [1.5 小结](Chapter-01/1.5-Summary.md)
* [第 2 章 开发 Web 应用程序](Chapter-02/Introduction.md)
    * [2.1 展示信息](Chapter-02/2.1-Displaying-information/Introduction.md)
        * [2.1.1 建立领域实体](Chapter-02/2.1-Displaying-information/2.1.1-Establishing-the-domain.md)
        * [2.1.2 创建控制器类](Chapter-02/2.1-Displaying-information/2.1.2-Creating-a-controller-class.md)
        * [2.1.3 设计视图](Chapter-02/2.1-Displaying-information/2.1.3-Designing-the-view.md)
    * [2.2 处理表单提交](Chapter-02/2.2-Processing-form-submission.md)
    * [2.3 验证表单输入](Chapter-02/2.3-Validating-form-input/Introduction.md)
        * [2.3.1 声明验证规则](Chapter-02/2.3-Validating-form-input/2.3.1-Declaring-validation-rules.md)
        * [2.3.2 在表单绑定时执行验证](Chapter-02/2.3-Validating-form-input/2.3.2-Performing-validation-at-form-binding.md)
        * [2.3.3 显示验证错误](Chapter-02/2.3-Validating-form-input/2.3.3-Displaying-validation-errors.md)
    * [2.4 使用视图控制器](Chapter-02/2.4-Working-with-view-controllers.md)
    * [2.5 选择视图模板库](Chapter-02/2.5-Choosing-a-view-template-library/Introduction.md)
        * [2.5.1 缓存模板](Chapter-02/2.5-Choosing-a-view-template-library/2.5.1-Caching-templates.md)
    * [2.6 总结](Chapter-02/2.6-Summary.md)

-----
* [第 9 章 发送异步消息](Chapter-09/Introduction.md)
    * [9.1 使用 JMS 发送消息](Chapter-09/9.1-Sending-messages-with-JMS/Introduction.md)
        * [9.1.1 设置 JMS](Chapter-09/9.1-Sending-messages-with-JMS/9.1.1-Setting-up-JMS.md)
        * [9.1.2 使用 JmsTemplate 发送消息](Chapter-09/9.1-Sending-messages-with-JMS/9.1.2-Sending-messages-with-JmsTemplate.md)
        * [9.1.3 接收 JMS 消息](Chapter-09/9.1-Sending-messages-with-JMS/9.1.3-Receiving-JMS-messages.md)
    * [9.2 使用 RabbitMQ 和 AMQP](Chapter-09/9.2-Working-with-RabbitMQ-and-AMQP/Introduction.md)
        * [9.2.1 添加 RabbitMQ 到 Spring 中](Chapter-09/9.2-Working-with-RabbitMQ-and-AMQP/9.2.1-Adding-RabbitMQ-to-Spring.md)
        * [9.2.2 使用 RabbitTemplate 发送消息](Chapter-09/9.2-Working-with-RabbitMQ-and-AMQP/9.2.2-Sending-messages-with-RabbitTemplate.md)
        * [9.2.3 从 RabbitMQ 接收消息](Chapter-09/9.2-Working-with-RabbitMQ-and-AMQP/9.2.3-Receiving-message-from-RabbitMQ.md)
    * [9.3 使用 Kafka 发送消息](Chapter-09/9.3-Messaging-with-Kafka/Introduction.md)
        * [9.3.1 在 Spring 中设置 Kafka](Chapter-09/9.3-Messaging-with-Kafka/9.3.1-Setting-up-Spring-for-Kafka-messaging.md)
        * [9.3.2 使用 KafkaTemplate 发送消息](Chapter-09/9.3-Messaging-with-Kafka/9.3.2-Sending-messages-with-KafkaTemplate.md)
        * [9.3.3 编写 Kafka 监听器](Chapter-09/9.3-Messaging-with-Kafka/9.3.3-Writing-Kafka-listeners.md)
    * [9.4 总结](Chapter-09/9.4-Summary.md)
* [第 10 章 集成 Spring](Chapter-10/Introduction.md)
    * [10.1 声明简单的集成流](Chapter-10/10.1-Declaring-a-simple-integration-flow/Introduction.md)
        * [10.1.1 使用 XML 定义集成流](Chapter-10/10.1-Declaring-a-simple-integration-flow/10.1.1-Defining-integration-flows-with-XML.md)
        * [10.1.2 在 Java 中配置集成流](Chapter-10/10.1-Declaring-a-simple-integration-flow/10.1.2-Configuring-integration-flows-in-Java.md)
        * [10.1.3 使用 Spring Integration 的 DSL 配置](Chapter-10/10.1-Declaring-a-simple-integration-flow/10.1.3-Using-Spring-Integration’s-DSL-configuration.md)
    * [10.2 探索 Spring Integration](Chapter-10/10.2-Surveying-the-Spring-Integration-landscape/Introduction.md)
        * [10.2.1 消息通道](Chapter-10/10.2-Surveying-the-Spring-Integration-landscape/10.2.1-Message-channels.md)
        * [10.2.2 过滤器](Chapter-10/10.2-Surveying-the-Spring-Integration-landscape/10.2.2-Filters.md)
        * [10.2.3 转换器](Chapter-10/10.2-Surveying-the-Spring-Integration-landscape/10.2.3-Transformers.md)
        * [10.2.4 路由](Chapter-10/10.2-Surveying-the-Spring-Integration-landscape/10.2.4-Routers.md)
        * [10.2.5 分割器](Chapter-10/10.2-Surveying-the-Spring-Integration-landscape/10.2.5-Splitters.md)
        * [10.2.6 服务激活器](Chapter-10/10.2-Surveying-the-Spring-Integration-landscape/10.2.6-Service-activators.md)
        * [10.2.7 网关](Chapter-10/10.2-Surveying-the-Spring-Integration-landscape/10.2.7-Gateways.md)
        * [10.2.8 通道适配器](Chapter-10/10.2-Surveying-the-Spring-Integration-landscape/10.2.8-Channel-adapters.md)
        * [10.2.9 端点模块](Chapter-10/10.2-Surveying-the-Spring-Integration-landscape/10.2.9-Endpoint-modules.md)
    * [10.3 创建 Email 集成流](Chapter-10/10.3-Creating-an-email-integration-flow.md)
    * [10.4 总结](Chapter-10/10.4-Summary.md)
* [第 11 章 Reactor 介绍](Chapter-11/Introduction.md)
    * [11.1 理解响应式编程](Chapter-11/11.1-Understanding-reactive-programming/Introduction.md)
        * [11.1.1 定义响应式流](Chapter-11/11.1-Understanding-reactive-programming/11.1.1-Defining-Reactive-Streams.md)
    * [11.2 使用 Reactor](Chapter-11/11.2-Getting-started-with-Reactor/Introduction.md)
        * [11.2.1 图解响应式流](Chapter-11/11.2-Getting-started-with-Reactor/11.2.1-Diagramming-reactive-flows.md)
        * [11.2.2 添加 Reactor 依赖](Chapter-11/11.2-Getting-started-with-Reactor/11.2.2-Adding-Reactor-dependencies.md)
    * [11.3 通用响应式操作实战](Chapter-11/11.3-Applying-common-reactive-operations/Introduction.md)
        * [11.3.1 创建响应式类型](Chapter-11/11.3-Applying-common-reactive-operations/11.3.1-Creating-reactive-types.md)
        * [11.3.2 响应式类型结合](Chapter-11/11.3-Applying-common-reactive-operations/11.3.2-Combining-reactive-types.md)
        * [11.3.3 转换和过滤响应式流](Chapter-11/11.3-Applying-common-reactive-operations/11.3.3-Transforming-and-filtering-reactive-streams.md)
        * [11.3.4 对响应类型执行逻辑操作](Chapter-11/11.3-Applying-common-reactive-operations/11.3.4-Performing-logic-operations-on-reactive-types.md)
    * [11.4 总结](Chapter-11/11.4-Summary.md)
* [第 12 章 开发响应式 API](Chapter-12/Introduction.md)
    * [12.1 使用 Spring WebFlux](Chapter-12/12.1-Working-with-Spring-WebFlux/Introduction.md)
        * [12.1.1 Spring WebFlux 介绍](Chapter-12/12.1-Working-with-Spring-WebFlux/12.1.1-Introducing-Spring-WebFlux.md)
        * [12.1.2 编写响应式 Controller](Chapter-12/12.1-Working-with-Spring-WebFlux/12.1.2-Writing-reactive-controllers.md)
    * [12.2 定义函数式请求处理程序](Chapter-12/12.2-Defining-functional-request-handlers.md)
    * [12.3 测试响应式 Controller](Chapter-12/12.3-Testing-reactive-controllers/Introduction.md)
        * [12.3.1 测试 GET 请求](Chapter-12/12.3-Testing-reactive-controllers/12.3.1-Testing-GET-requests.md)
        * [12.3.2 测试 POST 请求](Chapter-12/12.3-Testing-reactive-controllers/12.3.2-Testing-POST-requests.md)
        * [12.3.3 使用线上服务器进行测试](Chapter-12/12.3-Testing-reactive-controllers/12.3.3-Testing-with-a-live-server.md)
    * [12.4 响应式消费 REST API](Chapter-12/12.4-Consuming-REST-APIs-reactively/Introduction.md)
        * [12.4.1 获取资源](Chapter-12/12.4-Consuming-REST-APIs-reactively/12.4.1-GETting-resources.md)
        * [12.4.2 发送资源](Chapter-12/12.4-Consuming-REST-APIs-reactively/12.4.2-Sending-resources.md)
        * [12.4.3 删除资源](Chapter-12/12.4-Consuming-REST-APIs-reactively/12.4.3-Deleting-resources.md)
        * [12.4.4 处理错误](Chapter-12/12.4-Consuming-REST-APIs-reactively/12.4.4-Handling-errors.md)
        * [12.4.5 请求转换](Chapter-12/12.4-Consuming-REST-APIs-reactively/12.4.5-Exchanging-requests.md)
    * [12.5 保护响应式 web API](Chapter-12/12.5-Securing-reactive-web-APIs/Introduction.md)
        * [12.5.1 配置响应式 Web 安全](Chapter-12/12.5-Securing-reactive-web-APIs/12.5.1-Configuring-reactive-web-security.md)
        * [12.5.2 配置响应式用户信息服务](Chapter-12/12.5-Securing-reactive-web-APIs/12.5.2-Configuring-a-reactive-user-details-service.md)
    * [12.6 总结](Chapter-12/12.6-Summary.md)
* [第 13 章 响应式持久化数据](Chapter-13/Introduction.md)
    * [13.1 使用 R2DBC](Chapter-13/13.1-Working-with-R2DBC/Introduction.md)
        * [13.1.1 为 R2DBC 定义实体](Chapter-13/13.1-Working-with-R2DBC/13.1.1-Defining-domain-entities-for-R2DBC.md)
        * [13.1.2 定义响应式 Repository ](Chapter-13/13.1-Working-with-R2DBC/13.1.2-Defining-reactive-repositories.md)
        * [13.1.3 测试 R2DBC  Repository ](Chapter-13/13.1-Working-with-R2DBC/13.1.3-Testing-R2DBC-repositories.md)
        * [13.1.4 定义 OrderRepository 聚合根服务](Chapter-13/13.1-Working-with-R2DBC/13.1.4-Defining-an-OrderRepository-aggregate-root-service.md)
    * [13.2 使用 MongoDB 响应式保存文档](Chapter-13/13.2-Persisting-document-data-reactively-with-MongoDB/Introduction.md)
        * [13.2.1 定义文档类型](Chapter-13/13.2-Persisting-document-data-reactively-with-MongoDB/13.2.1-Defining-domain-document-types.md)
        * [13.2.2 定义响应式 MongoDB  Repository ](Chapter-13/13.2-Persisting-document-data-reactively-with-MongoDB/13.2.2-Defining-reactive-MongoDB-repositories.md)
        * [13.2.3 测试响应式 MongoDB  Repository ](Chapter-13/13.2-Persisting-document-data-reactively-with-MongoDB/13.2.3-Testing-reactive-MongoDB-repositories.md)
    * [13.3 使用 Cassandra 响应式保存数据](Chapter-13/13.3-Reactively-persisting-data-in-Cassandra/Introduction.md)
        * [13.2.1 为 Cassandra 定义实体类](Chapter-13/13.3-Reactively-persisting-data-in-Cassandra/13.3.1-Defining-domain-classes-for-Cassandra-persistence.md)
        * [13.2.2 创建响应式 Cassandra  Repository ](Chapter-13/13.3-Reactively-persisting-data-in-Cassandra/13.3.2-Creating-reactive-Cassandra-repositories.md)
        * [13.2.3 测试响应式 Cassandra  Repository ](Chapter-13/13.3-Reactively-persisting-data-in-Cassandra/13.3.3-Testing-reactive-Cassandra-repositories.md)
    * [13.4 总结](Chapter-13/13.4-Summary.md)
* [第 14 章 使用 RSocket](Chapter-14/Introduction.md)
    * [14.1 介绍 RSocket](Chapter-14/14.1-Introducing-RSocket.md)
    * [14.2 创建一个简单的 RSocket 服务端和客户端](Chapter-14/14.2-Creating-a-simple-RSocket-server-and-client/Introduction.md)
        * [14.2.1 使用 请求/响应 模型](Chapter-14/14.2-Creating-a-simple-RSocket-server-and-client/14.2.1-Working-with-Request-Response.md)
        * [14.2.2 处理 请求/流 消息](Chapter-14/14.2-Creating-a-simple-RSocket-server-and-client/14.2.2-Handling-request-stream-messaging.md)
        * [14.2.3 发送 即发即忘 消息](Chapter-14/14.2-Creating-a-simple-RSocket-server-and-client/14.2.3-Sending-Fire-and-Forget-messages.md)
        * [14.2.4 双向发送消息](Chapter-14/14.2-Creating-a-simple-RSocket-server-and-client/14.2.4-Sending-messages-bidirectionally.md)
    * [14.3 在 WebSocket 上进行 RSocket 传输](Chapter-14/14.3-Transporting-RSocket-over-WebSocket.md)
    * [14.4 总结](Chapter-14/14.4-Summary.md)
* [第 15 章 使用 Spring Boot Actuator](Chapter-15/Introduction.md)
    * [15.1 介绍 Actuator](Chapter-15/15.1-Introducing-Actuator/Introduction.md)
        * [15.1.1 配置 Actuator 基本路径](Chapter-15/15.1-Introducing-Actuator/15.1.1-Configuring-Actuator's-base-path.md)
        * [15.1.2 启用和禁用 Actuator 端点](Chapter-15/15.1-Introducing-Actuator/15.1.2-Enabling-and-disabling-Actuator-endpoints.md)
    * [15.2 使用 Actuator 端点](Chapter-15/15.2-Consuming-Actuator-endpoints/Introduction.md)
        * [15.2.1 获取重要的应用程序信息](Chapter-15/15.2-Consuming-Actuator-endpoints/15.2.1-Fetching-essential-application-information.md)
        * [15.2.2 查看配置详细信息](Chapter-15/15.2-Consuming-Actuator-endpoints/15.2.2-Viewing-configuration-details.md)
        * [15.2.3 查看应用程序活动](Chapter-15/15.2-Consuming-Actuator-endpoints/15.2.3-Viewing-application-activity.md)
        * [15.2.4 利用运行时指标](Chapter-15/15.2-Consuming-Actuator-endpoints/15.2.4-Tapping-runtime-metrics.md)
    * [15.3 自定义 Actuator](Chapter-15/15.3-Customizing-Actuator/Introduction.md)
        * [15.3.1 向 /info 端点提供信息](Chapter-15/15.3-Customizing-Actuator/15.3.1-Contributing-information-to-the-info-endpoint.md)
        * [15.3.2 自定义健康指标](Chapter-15/15.3-Customizing-Actuator/15.3.2-Defining-custom-health-indicators.md)
        * [15.3.3 注册自定义指标](Chapter-15/15.3-Customizing-Actuator/15.3.3-Registering-custom-metrics.md)
        * [15.3.4 创建自定义端点](Chapter-15/15.3-Customizing-Actuator/15.3.4-Creating-custom-endpoints.md)
    * [15.4 保护 Actuator](Chapter-15/15.4-Securing-Actuator.md)
    * [15.5 总结](Chapter-15/15.5-Summary.md)
* [第 16 章 管理 Spring](Chapter-16/Introduction.md)
    * [16.1 使用 SpringBoot Admin](Chapter-16/16.1-Using-Spring-Boot-Admin/Introduction.md)
        * [16.1.1 创建 Admin 服务端](Chapter-16/16.1-Using-Spring-Boot-Admin/16.1.1-Creating-an-Admin-server.md)
        * [16.1.2 注册 Admin 客户端](Chapter-16/16.1-Using-Spring-Boot-Admin/16.1.2-Registering-Admin-clients.md)
    * [16.2 深入 Admin 服务端](Chapter-16/16.2-Exploring-the-Admin-server/Introduction.md)
        * [16.2.1 查看普通应用程序运行状况和信息](Chapter-16/16.2-Exploring-the-Admin-server/16.2.1-Viewing-general-application-health-and-information.md)
        * [16.2.2 观察关键指标](Chapter-16/16.2-Exploring-the-Admin-server/16.2.2-Watching-key-metrics.md)
        * [16.2.3 检查环境属性](Chapter-16/16.2-Exploring-the-Admin-server/16.2.3-Examining-environment-properties.md)
        * [16.2.4 查看并设置 log 级别](Chapter-16/16.2-Exploring-the-Admin-server/16.2.4-Viewing-and-setting-logging-levels.md)
    * [16.3 保护 Admin 服务端](Chapter-16/16.3-Securing-the-Admin-server/Introduction.md)
        * [16.3.1 在 Admin 服务端中启用登录](Chapter-16/16.3-Securing-the-Admin-server/16.3.1-Enabling-login-in-the-Admin-server.md)
        * [16.3.2 使用 Actuator 进行认证](Chapter-16/16.3-Securing-the-Admin-server/16.3.2-Authenticating-with-the-Actuator.md)
    * [16.4 总结](Chapter-16/16.4-Summary.md)
* [第 17 章 使用 JMX 监控 Spring](Chapter-17/Introduction.md)
    * [17.1 使用 Actuator MBean](Chapter-17/17.1-Working-with-Actuator-MBeans.md)
    * [17.2 创建自己的 MBean](Chapter-17/17.2-Creating-your-own-MBeans.md)
    * [17.3 发送通知](Chapter-17/17.3-Sending-notifications.md)
    * [17.4 总结](Chapter-17/17.4-Summary.md)
* [第 18 章 部署 Spring](Chapter-18/Introduction.md)
    * [18.1 权衡部署选项](Chapter-18/18.1-Weighing-deployment-options.md)
    * [18.2 构建可执行 JAR 文件](Chapter-18/18.2-Building-executable-JAR-files.md)
    * [18.3 构建容器镜像](Chapter-18/18.3-Building-container-images/Introduction.md)
        * [18.3.1 部署到 Kubernetes](Chapter-18/18.3-Building-container-images/18.3.1-Deploying-to-Kubernetes.md)
        * [18.3.2 启用优雅关闭](Chapter-18/18.3-Building-container-images/18.3.2-Enabling-graceful-shutdown.md)
        * [18.3.3 应用存活性和可用性](Chapter-18/18.3-Building-container-images/18.3.3-Working-with-application-liveness-and-readiness.md)
    * [18.4 构建并部署 WAR 文件](Chapter-18/18.4-Building-and-deploying-WAR-files.md)
    * [18.5 终章](Chapter-18/18.5-The-end-is-where-we-begin.md)
    * [18.6 总结](Chapter-18/18.6-Summary.md)

